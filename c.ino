#include <avr/io.h>   //hardware registers
#include <util/twi.h> //TWI status masks

// default to Arduino oscillator
#ifndef F_CPU
#define F_CPU 16000000UL
#warning "F_CPU not defined! Assuming 16MHz."
#endif

#ifndef TWI_FREQUENCY
#define TWI_FREQUENCY 400000
#endif

#define VREF 5

// set prescaler so that the TWBR value is as large as possible
// and at least 10 (frequency error below 5%)
// https://www.nongnu.org/avr-libc/user-manual/group__twi__demo.html Note[5]
#if (F_CPU / TWI_FREQUENCY - 16) / (2 * 1) >= 10 && (F_CPU / TWI_FREQUENCY - 16) / (2 * 1) <= 0xFF
#define TWI_PRESCALER 1
#define TWPS0_VALUE 0
#define TWPS1_VALUE 0
#elif (F_CPU / TWI_FREQUENCY - 16) / (2 * 4) >= 10 && (F_CPU / TWI_FREQUENCY - 16) / (2 * 4) <= 0xFF
#define TWI_PRESCALER 4
#define TWPS0_VALUE 1
#define TWPS1_VALUE 0
#elif (F_CPU / TWI_FREQUENCY - 16) / (2 * 16) >= 10 && (F_CPU / TWI_FREQUENCY - 16) / (2 * 16) <= 0xFF
#define TWI_PRESCALER 16
#define TWPS0_VALUE 0
#define TWPS1_VALUE 1
#elif (F_CPU / TWI_FREQUENCY - 16) / (2 * 64) >= 10 && (F_CPU / TWI_FREQUENCY - 16) / (2 * 64) <= 0xFF
#define TWI_PRESCALER 64
#define TWPS0_VALUE 1
#define TWPS1_VALUE 1
#else
#error "TWI_FREQUENCY too low!"
#endif

#define TWBR_VALUE ((F_CPU / TWI_FREQUENCY - 16) / (2 * TWI_PRESCALER))

/** Mask TWI slave addressing byte with given id and write intend. */
#define TWI_ADDRESS_W(id) (((id) << 1) & ~0x01)
/** Mask TWI slave addressing byte  with given id and read intend. */
#define TWI_ADDRESS_R(id) (((id) << 1) | 0x01)


// a 5x7 font table
const uint8_t font57[] PROGMEM = {
    // This appears to be using Code Page 437
    // Hex codes provided because you probably aren't
    0x00, 0x00, 0x00, 0x00, 0x00, //    \x00
    0x3E, 0x5B, 0x4F, 0x5B, 0x3E, // ‚ò∫  \x01
    0x3E, 0x6B, 0x4F, 0x6B, 0x3E, // ‚òª  \x02
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C, // ‚ô•  \x03
    0x18, 0x3C, 0x7E, 0x3C, 0x18, // ‚ô¶  \x04
    0x1C, 0x57, 0x7D, 0x57, 0x1C, // ‚ô£  \x05
    0x1C, 0x5E, 0x7F, 0x5E, 0x1C, // ‚ô†  \x06
    0x00, 0x18, 0x3C, 0x18, 0x00, // ‚Ä¢  \x07
    0xFF, 0xE7, 0xC3, 0xE7, 0xFF, // ‚óò  \x08
    0x00, 0x18, 0x24, 0x18, 0x00, // ‚óã  \x09
    0xFF, 0xE7, 0xDB, 0xE7, 0xFF, // ‚óô  \x0a
    0x30, 0x48, 0x3A, 0x06, 0x0E, // ‚ôÇ  \x0b
    0x26, 0x29, 0x79, 0x29, 0x26, // ‚ôÄ  \x0c
    0x40, 0x7F, 0x05, 0x05, 0x07, // ‚ô™  \x0d
    0x40, 0x7F, 0x05, 0x25, 0x3F, // ‚ô´  \x0e
    0x5A, 0x3C, 0xE7, 0x3C, 0x5A, // ‚òº  \x0f
    0x7F, 0x3E, 0x1C, 0x1C, 0x08, // ‚ñ∫  \x10
    0x08, 0x1C, 0x1C, 0x3E, 0x7F, // ‚óÄ  \x11
    0x14, 0x22, 0x7F, 0x22, 0x14, // ‚Üï  \x12
    0x5F, 0x5F, 0x00, 0x5F, 0x5F, // ‚Äº  \x13
    0x06, 0x09, 0x7F, 0x01, 0x7F, // ¬∂  \x14
    0x00, 0x66, 0x89, 0x95, 0x6A, // ¬ß  \x15
    0x60, 0x60, 0x60, 0x60, 0x60, // ‚ñ¨  \x16
    0x94, 0xA2, 0xFF, 0xA2, 0x94, // ‚Ü®  \x17
    0x08, 0x04, 0x7E, 0x04, 0x08, // ‚Üë  \x18
    0x10, 0x20, 0x7E, 0x20, 0x10, // ‚Üì  \x19
    0x08, 0x08, 0x2A, 0x1C, 0x08, // ‚Üí  \x1a
    0x08, 0x1C, 0x2A, 0x08, 0x08, // ‚Üê  \x1b
    0x1E, 0x10, 0x10, 0x10, 0x10, // ‚àü  \x1c
    0x0C, 0x1E, 0x0C, 0x1E, 0x0C, // ‚Üî  \x1d
    0x30, 0x38, 0x3E, 0x38, 0x30, // ‚ñ≤  \x1e
    0x06, 0x0E, 0x3E, 0x0E, 0x06, // ‚ñº  \x1f
    0x00, 0x00, 0x00, 0x00, 0x00, // SP  \x20
    0x00, 0x00, 0x5F, 0x00, 0x00, // !  \x21
    0x00, 0x07, 0x00, 0x07, 0x00, // "  \x22
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #  \x23
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $  \x24
    0x23, 0x13, 0x08, 0x64, 0x62, // %  \x25
    0x36, 0x49, 0x56, 0x20, 0x50, // &  \x26
    0x00, 0x08, 0x07, 0x03, 0x00, // '  \x27
    0x00, 0x1C, 0x22, 0x41, 0x00, // (  \x28
    0x00, 0x41, 0x22, 0x1C, 0x00, // )  \x29
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A, // *  \x2a
    0x08, 0x08, 0x3E, 0x08, 0x08, // +  \x2b
    0x00, 0x80, 0x70, 0x30, 0x00, // ,  \x2c
    0x08, 0x08, 0x08, 0x08, 0x08, // -  \x2d
    0x00, 0x00, 0x60, 0x60, 0x00, // .  \x2e
    0x20, 0x10, 0x08, 0x04, 0x02, // /  \x2f
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0  \x30
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1  \x31
    0x72, 0x49, 0x49, 0x49, 0x46, // 2  \x32
    0x21, 0x41, 0x49, 0x4D, 0x33, // 3  \x33
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4  \x34
    0x27, 0x45, 0x45, 0x45, 0x39, // 5  \x35
    0x3C, 0x4A, 0x49, 0x49, 0x31, // 6  \x36
    0x41, 0x21, 0x11, 0x09, 0x07, // 7  \x37
    0x36, 0x49, 0x49, 0x49, 0x36, // 8  \x38
    0x46, 0x49, 0x49, 0x29, 0x1E, // 9  \x39
    0x00, 0x00, 0x14, 0x00, 0x00, // :  \x3a
    0x00, 0x40, 0x34, 0x00, 0x00, // ;  \x3b
    0x00, 0x08, 0x14, 0x22, 0x41, // <  \x3c
    0x14, 0x14, 0x14, 0x14, 0x14, // =  \x3d
    0x00, 0x41, 0x22, 0x14, 0x08, // >  \x3e
    0x02, 0x01, 0x59, 0x09, 0x06, // ?  \x3f
    0x3E, 0x41, 0x5D, 0x59, 0x4E, // @  \x40
    0x7C, 0x12, 0x11, 0x12, 0x7C, // A  \x41
    0x7F, 0x49, 0x49, 0x49, 0x36, // B  \x42
    0x3E, 0x41, 0x41, 0x41, 0x22, // C  \x43
    0x7F, 0x41, 0x41, 0x41, 0x3E, // D  \x44
    0x7F, 0x49, 0x49, 0x49, 0x41, // E  \x45
    0x7F, 0x09, 0x09, 0x09, 0x01, // F  \x46
    0x3E, 0x41, 0x41, 0x51, 0x73, // G  \x47
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H  \x48
    0x00, 0x41, 0x7F, 0x41, 0x00, // I  \x49
    0x20, 0x40, 0x41, 0x3F, 0x01, // J  \x4a
    0x7F, 0x08, 0x14, 0x22, 0x41, // K  \x4b
    0x7F, 0x40, 0x40, 0x40, 0x40, // L  \x4c
    0x7F, 0x02, 0x1C, 0x02, 0x7F, // M  \x4d
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N  \x4e
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O  \x4f
    0x7F, 0x09, 0x09, 0x09, 0x06, // P  \x50
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q  \x51
    0x7F, 0x09, 0x19, 0x29, 0x46, // R  \x52
    0x26, 0x49, 0x49, 0x49, 0x32, // S  \x53
    0x03, 0x01, 0x7F, 0x01, 0x03, // T  \x54
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U  \x55
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V  \x56
    0x3F, 0x40, 0x38, 0x40, 0x3F, // W  \x57
    0x63, 0x14, 0x08, 0x14, 0x63, // X  \x58
    0x03, 0x04, 0x78, 0x04, 0x03, // Y  \x59
    0x61, 0x59, 0x49, 0x4D, 0x43, // Z  \x5a
    0x00, 0x7F, 0x41, 0x41, 0x41, // [  \x5b
    0x02, 0x04, 0x08, 0x10, 0x20, // \  \x5c
    0x00, 0x41, 0x41, 0x41, 0x7F, // ]  \x5d
    0x04, 0x02, 0x01, 0x02, 0x04, // ^  \x5e
    0x40, 0x40, 0x40, 0x40, 0x40, // _  \x5f
    0x00, 0x03, 0x07, 0x08, 0x00, // `  \x60
    0x20, 0x54, 0x54, 0x78, 0x40, // a  \x61
    0x7F, 0x28, 0x44, 0x44, 0x38, // b  \x62
    0x38, 0x44, 0x44, 0x44, 0x28, // c  \x63
    0x38, 0x44, 0x44, 0x28, 0x7F, // d  \x64
    0x38, 0x54, 0x54, 0x54, 0x18, // e  \x65
    0x00, 0x08, 0x7E, 0x09, 0x02, // f  \x66
    0x18, 0xA4, 0xA4, 0x9C, 0x78, // g  \x67
    0x7F, 0x08, 0x04, 0x04, 0x78, // h  \x68
    0x00, 0x44, 0x7D, 0x40, 0x00, // i  \x69
    0x20, 0x40, 0x40, 0x3D, 0x00, // j  \x6a
    0x7F, 0x10, 0x28, 0x44, 0x00, // k  \x6b
    0x00, 0x41, 0x7F, 0x40, 0x00, // l  \x6c
    0x7C, 0x04, 0x78, 0x04, 0x78, // m  \x6d
    0x7C, 0x08, 0x04, 0x04, 0x78, // n  \x6e
    0x38, 0x44, 0x44, 0x44, 0x38, // o  \x6f
    0xFC, 0x18, 0x24, 0x24, 0x18, // p  \x70
    0x18, 0x24, 0x24, 0x18, 0xFC, // q  \x71
    0x7C, 0x08, 0x04, 0x04, 0x08, // r  \x72
    0x48, 0x54, 0x54, 0x54, 0x24, // s  \x73
    0x04, 0x04, 0x3F, 0x44, 0x24, // t  \x74
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u  \x75
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v  \x76
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w  \x77
    0x44, 0x28, 0x10, 0x28, 0x44, // x  \x78
    0x4C, 0x90, 0x90, 0x90, 0x7C, // y  \x79
    0x44, 0x64, 0x54, 0x4C, 0x44, // z  \x7a
    0x00, 0x08, 0x36, 0x41, 0x00, // {  \x7b
    0x00, 0x00, 0x77, 0x00, 0x00, // |  \x7c
    0x00, 0x41, 0x36, 0x08, 0x00, // }  \x7d
    0x02, 0x01, 0x02, 0x04, 0x02, // ~  \x7e
    0x3C, 0x26, 0x23, 0x26, 0x3C, // ‚åÇ  \x7f
    0x1E, 0xA1, 0xA1, 0x61, 0x12, // √á  \x80
    0x3A, 0x40, 0x40, 0x20, 0x7A, // √º  \x81
    0x38, 0x54, 0x54, 0x55, 0x59, // √©  \x82
    0x21, 0x55, 0x55, 0x79, 0x41, // √¢  \x83
    0x21, 0x54, 0x54, 0x78, 0x41, // √§  \x84
    0x21, 0x55, 0x54, 0x78, 0x40, // √†  \x85
    0x20, 0x54, 0x55, 0x79, 0x40, // √•  \x86
    0x0C, 0x1E, 0x52, 0x72, 0x12, // √ß  \x87
    0x39, 0x55, 0x55, 0x55, 0x59, // √™  \x88
    0x39, 0x54, 0x54, 0x54, 0x59, // √´  \x89
    0x39, 0x55, 0x54, 0x54, 0x58, // √®  \x8a
    0x00, 0x00, 0x45, 0x7C, 0x41, // √Ø  \x8b
    0x00, 0x02, 0x45, 0x7D, 0x42, // √Æ  \x8c
    0x00, 0x01, 0x45, 0x7C, 0x40, // √¨  \x8d
    0xF0, 0x29, 0x24, 0x29, 0xF0, // √Ñ  \x8e
    0xF0, 0x28, 0x25, 0x28, 0xF0, // √Ö  \x8f
    0x7C, 0x54, 0x55, 0x45, 0x00, // √â  \x90
    0x20, 0x54, 0x54, 0x7C, 0x54, // √¶  \x91
    0x7C, 0x0A, 0x09, 0x7F, 0x49, // √Ü  \x92
    0x32, 0x49, 0x49, 0x49, 0x32, // √¥  \x93
    0x32, 0x48, 0x48, 0x48, 0x32, // √∂  \x94
    0x32, 0x4A, 0x48, 0x48, 0x30, // √≤  \x95
    0x3A, 0x41, 0x41, 0x21, 0x7A, // √ª  \x96
    0x3A, 0x42, 0x40, 0x20, 0x78, // √π  \x97
    0x00, 0x9D, 0xA0, 0xA0, 0x7D, // √ø  \x98
    0x39, 0x44, 0x44, 0x44, 0x39, // √ñ  \x99
    0x3D, 0x40, 0x40, 0x40, 0x3D, // √ú  \x9a
    0x3C, 0x24, 0xFF, 0x24, 0x24, // ¬¢  \x9b
    0x48, 0x7E, 0x49, 0x43, 0x66, // ¬£  \x9c
    0x2B, 0x2F, 0xFC, 0x2F, 0x2B, // ¬•  \x9d
    0xFF, 0x09, 0x29, 0xF6, 0x20, // ‚Çß  \x9e
    0xC0, 0x88, 0x7E, 0x09, 0x03, // ∆í  \x9f
    0x20, 0x54, 0x54, 0x79, 0x41, // √°  \xa0
    0x00, 0x00, 0x44, 0x7D, 0x41, // √≠  \xa1
    0x30, 0x48, 0x48, 0x4A, 0x32, // √≥  \xa2
    0x38, 0x40, 0x40, 0x22, 0x7A, // √∫  \xa3
    0x00, 0x7A, 0x0A, 0x0A, 0x72, // √±  \xa4
    0x7D, 0x0D, 0x19, 0x31, 0x7D, // √ë  \xa5
    0x26, 0x29, 0x29, 0x2F, 0x28, // ¬™  \xa6
    0x26, 0x29, 0x29, 0x29, 0x26, // ¬∫  \xa7
    0x30, 0x48, 0x4D, 0x40, 0x20, // ¬ø  \xa8
    0x38, 0x08, 0x08, 0x08, 0x08, // ‚åê  \xa9
    0x08, 0x08, 0x08, 0x08, 0x38, // ¬¨  \xaa
    0x2F, 0x10, 0xC8, 0xAC, 0xBA, // ¬Ω  \xab
    0x2F, 0x10, 0x28, 0x34, 0xFA, // ¬º  \xac
    0x00, 0x00, 0x7B, 0x00, 0x00, // ¬°  \xad
    0x08, 0x14, 0x2A, 0x14, 0x22, // ¬´  \xae
    0x22, 0x14, 0x2A, 0x14, 0x08, // ¬ª  \xaf
    0xAA, 0x00, 0x55, 0x00, 0xAA, // ‚ñë  \xb0
    0xAA, 0x55, 0xAA, 0x55, 0xAA, // ‚ñí  \xb1
    0xAA, 0xFF, 0xAA, 0xFF, 0xAA, // ‚ñì  \xb2
    0x00, 0x00, 0x00, 0xFF, 0x00, // ‚îÇ  \xb3
    0x10, 0x10, 0x10, 0xFF, 0x00, // ‚î§  \xb4
    0x14, 0x14, 0x14, 0xFF, 0x00, // ‚ï°  \xb5
    0x10, 0x10, 0xFF, 0x00, 0xFF, // ‚ï¢  \xb6
    0x10, 0x10, 0xF0, 0x10, 0xF0, // ‚ïñ  \xb7
    0x14, 0x14, 0x14, 0xFC, 0x00, // ‚ïï  \xb8
    0x14, 0x14, 0xF7, 0x00, 0xFF, // ‚ï£  \xb9
    0x00, 0x00, 0xFF, 0x00, 0xFF, // ‚ïë  \xba
    0x14, 0x14, 0xF4, 0x04, 0xFC, // ‚ïó  \xbb
    0x14, 0x14, 0x17, 0x10, 0x1F, // ‚ïù  \xbc
    0x10, 0x10, 0x1F, 0x10, 0x1F, // ‚ïú  \xbd
    0x14, 0x14, 0x14, 0x1F, 0x00, // ‚ïõ  \xbe
    0x10, 0x10, 0x10, 0xF0, 0x00, // ‚îê  \xbf
    0x00, 0x00, 0x00, 0x1F, 0x10, // ‚îî  \xc0
    0x10, 0x10, 0x10, 0x1F, 0x10, // ‚î¥  \xc1
    0x10, 0x10, 0x10, 0xF0, 0x10, // ‚î¨  \xc2
    0x00, 0x00, 0x00, 0xFF, 0x10, // ‚îú  \xc3
    0x10, 0x10, 0x10, 0x10, 0x10, // ‚îÄ  \xc4
    0x10, 0x10, 0x10, 0xFF, 0x10, // ‚îº  \xc5
    0x00, 0x00, 0x00, 0xFF, 0x14, // ‚ïû  \xc6
    0x00, 0x00, 0xFF, 0x00, 0xFF, // ‚ïü  \xc7
    0x00, 0x00, 0x1F, 0x10, 0x17, // ‚ïö  \xc8
    0x00, 0x00, 0xFC, 0x04, 0xF4, // ‚ïî  \xc9
    0x14, 0x14, 0x17, 0x10, 0x17, // ‚ï©  \xca
    0x14, 0x14, 0xF4, 0x04, 0xF4, // ‚ï¶  \xcb
    0x00, 0x00, 0xFF, 0x00, 0xF7, // ‚ï†  \xcc
    0x14, 0x14, 0x14, 0x14, 0x14, // ‚ïê  \xcd
    0x14, 0x14, 0xF7, 0x00, 0xF7, // ‚ï¨  \xce
    0x14, 0x14, 0x14, 0x17, 0x14, // ‚ïß  \xcf
    0x10, 0x10, 0x1F, 0x10, 0x1F, // ‚ï®  \xd0
    0x14, 0x14, 0x14, 0xF4, 0x14, // ‚ï§  \xd1
    0x10, 0x10, 0xF0, 0x10, 0xF0, // ‚ï•  \xd2
    0x00, 0x00, 0x1F, 0x10, 0x1F, // ‚ïô  \xd3
    0x00, 0x00, 0x00, 0x1F, 0x14, // ‚ïò  \xd4
    0x00, 0x00, 0x00, 0xFC, 0x14, // ‚ïí  \xd5
    0x00, 0x00, 0xF0, 0x10, 0xF0, // ‚ïì  \xd6
    0x10, 0x10, 0xFF, 0x10, 0xFF, // ‚ï´  \xd7
    0x14, 0x14, 0x14, 0xFF, 0x14, // ‚ï™  \xd8
    0x10, 0x10, 0x10, 0x1F, 0x00, // ‚îò  \xd9
    0x00, 0x00, 0x00, 0xF0, 0x10, // ‚îå  \xda
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // ‚ñà  \xdb
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, // ‚ñÑ  \xdc
    0xFF, 0xFF, 0xFF, 0x00, 0x00, // ‚ñå  \xdd
    0x00, 0x00, 0x00, 0xFF, 0xFF, // ‚ñê  \xde
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, // ‚ñÄ  \xdf
    0x38, 0x44, 0x44, 0x38, 0x44, // Œ±  \xe0
    0x7C, 0x2A, 0x2A, 0x3E, 0x14, // √ü  \xe1
    0x7E, 0x02, 0x02, 0x06, 0x06, // Œì  \xe2
    0x02, 0x7E, 0x02, 0x7E, 0x02, // œÄ  \xe3
    0x63, 0x55, 0x49, 0x41, 0x63, // Œ£  \xe4
    0x38, 0x44, 0x44, 0x3C, 0x04, // œÉ  \xe5
    0x40, 0x7E, 0x20, 0x1E, 0x20, // ¬µ  \xe6
    0x06, 0x02, 0x7E, 0x02, 0x02, // œÑ  \xe7
    0x99, 0xA5, 0xE7, 0xA5, 0x99, // Œ¶  \xe8
    0x1C, 0x2A, 0x49, 0x2A, 0x1C, // Œò  \xe9
    0x4C, 0x72, 0x01, 0x72, 0x4C, // Œ©  \xea
    0x30, 0x4A, 0x4D, 0x4D, 0x30, // Œ¥  \xeb
    0x30, 0x48, 0x78, 0x48, 0x30, // ‚àû  \xec
    0xBC, 0x62, 0x5A, 0x46, 0x3D, // œÜ  \xed
    0x3E, 0x49, 0x49, 0x49, 0x00, // Œµ  \xee
    0x7E, 0x01, 0x01, 0x01, 0x7E, // ‚à©  \xef
    0x2A, 0x2A, 0x2A, 0x2A, 0x2A, // ‚â°  \xf0
    0x44, 0x44, 0x5F, 0x44, 0x44, // ¬±  \xf1
    0x40, 0x51, 0x4A, 0x44, 0x40, // ‚â•  \xf2
    0x40, 0x44, 0x4A, 0x51, 0x40, // ‚â§  \xf3
    0x00, 0x00, 0xFF, 0x01, 0x03, // ‚å†  \xf4
    0xE0, 0x80, 0xFF, 0x00, 0x00, // ‚å°  \xf5
    0x08, 0x08, 0x6B, 0x6B, 0x08, // √∑  \xf6
    0x36, 0x12, 0x36, 0x24, 0x36, // ‚âà  \xf7
    0x06, 0x0F, 0x09, 0x0F, 0x06, // ¬∞  \xf8
    0x00, 0x00, 0x18, 0x18, 0x00, // ‚àô  \xf9
    0x00, 0x00, 0x10, 0x10, 0x00, // ¬∑  \xfa
    0x30, 0x40, 0xFF, 0x01, 0x01, // ‚àö  \xfb
    0x00, 0x1F, 0x01, 0x01, 0x1E, // ‚Åø  \xfc
    0x00, 0x19, 0x1D, 0x17, 0x12, // ¬≤  \xfd
    0x00, 0x3C, 0x3C, 0x3C, 0x3C, // ‚ñ†  \xfe
    0x80, 0x00, 0x00, 0x00, 0x00, // NBSP  \xff
};

volatile int BPM;               // int that holds raw Analog in 0. updated every 2mS
volatile int Signal;            // holds the incoming raw data
volatile int IBI = 600;         // int that holds the time interval between beats! Must be seeded!
volatile boolean Pulse = false; // "True" when User's live heartbeat is detected. "False" when not a "live beat".
volatile boolean QS = false;    // becomes true when Arduoino finds a beat.

static boolean serialVisual = true; // Set to 'false' by Default.  Re-set to 'true' to see Arduino Serial Monitor ASCII Visual Pulse

volatile int rate[10];                    // array to hold last ten IBI values
volatile unsigned long sampleCounter = 0; // used to determine pulse timing
volatile unsigned long lastBeatTime = 0;  // used to find IBI
volatile int P = 512;                     // used to find peak in pulse wave, seeded
volatile int T = 512;                     // used to find trough in pulse wave, seeded
volatile int thresh = 525;                // used to find instant moment of heart beat, seeded
volatile int amp = 100;                   // used to hold amplitude of pulse waveform, seeded
volatile boolean firstBeat = true;        // used to seed rate array so we startup with reasonable BPM
volatile boolean secondBeat = false;      // used to seed rate array so we startup with reasonable BPM

void twi_init(void)
{
  TWBR = TWBR_VALUE;
  TWSR = (TWPS1_VALUE << TWPS1) | (TWPS0_VALUE << TWPS0);
  TWCR = (1 << TWEN);
}

static void twi_waitForComplete(void)
{
  while (~TWCR & (1 << TWINT)) // TWINT HIGH 0
    ;
}

bool twi_start(void)
{
  // set twint 1 clear flag, twsta 1 start condition , twen 1 enable twi
  TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN); // hehe dinh vai ca dai :)) TWINT luu dia chi bit, 1 shift qua dia chi bit Du Ma doc quai moi hieu code
  twi_waitForComplete();
  return TW_STATUS != TW_START;
}

void twi_stop(void)
{
  TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
}

void repStart(void)
{
  TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
  twi_waitForComplete();
  return TW_STATUS != TW_REP_START;
}

bool twi_addressWrite(uint8_t address)
{
  TWDR = TWI_ADDRESS_W(address);
  TWCR = (1 << TWINT) | (1 << TWEN);

  twi_waitForComplete();

  return TW_STATUS != TW_MT_SLA_ACK;
}

bool twi_addressRead(uint8_t address)
{
  TWDR = TWI_ADDRESS_R(address);
  TWCR = (1 << TWINT) | (1 << TWEN);

  twi_waitForComplete();

  return TW_STATUS != TW_MR_SLA_ACK;
}

bool twi_write(uint8_t data)
{
  TWDR = data;
  TWCR = (1 << TWINT) | (1 << TWEN);

  twi_waitForComplete();

  return TW_STATUS != TW_MT_DATA_ACK;
}

// OLED Constants
int const address = 60;
int const commands = 0x00;
int const onecommand = 0x80;
int const data = 0x40;
int const onedata = 0xC0;

// OLED display **********************************************

void oled_init()
{
  twi_start();
  twi_addressWrite(address);
  twi_write(commands);

  twi_write(0x20); // set memory mode
  //                       ,-- not supported on my devices üò¶ (ignored)
  twi_write(0x02); // 00=horizontal, 01=vertical, 02=page

  twi_write(0xA1); // horizontal flip: 0xA0=off 0xA1=on
  twi_write(0xC8); // vertical flip:   0xC0=off 0xC8=on

  twi_write(0xDB); // set vcom detect
  twi_write(0x40); // brightness

  twi_write(0x81);
  twi_write(0x80); // set constrast

  twi_write(0x21);
  twi_write(0);
  twi_write(127); // column range
  twi_write(0x22);
  twi_write(0);
  twi_write(7); // page range

  // only charge pump and display on were required for my Bangood
  // purchase (https://banggood.app.link/nO5rGtZfphb)
  twi_write(0x8D);
  twi_write(0x14); // charge pump
  twi_write(0xAF); // display on
  twi_stop();
}
void oled_goto(uint8_t column, uint8_t page)
{
  twi_start();
  twi_addressWrite(address);
  twi_write(commands);
  twi_write(0x00 | (0x0F & (column << 0))); // column lower nibble
  twi_write(0x10 | (0x0F & (column >> 4))); // column upper nibble
  twi_write(0xB0 | page);
  twi_stop();
}
void oled_page(uint8_t page)
{
  twi_start();
  twi_addressWrite(address);
  twi_write(commands);
  twi_write(0xB0 | page);
  twi_stop();
}
void oled_fill(uint8_t number, uint8_t filler)
{
  twi_start();
  twi_addressWrite(address);
  twi_write(0x40); // data mode (sending screen content)

  for (uint8_t i = 0; i < number; i++)
  {
    twi_write(filler);
  }
  twi_stop();
}
void oled_clear(uint8_t white)
{
  for (uint8_t page = 0; page < 8; page++)
  {
    oled_page(page);
    oled_fill(128, white ? 0xFF : 0x00);
  }
}
void oled_print(const char ch)
{
  twi_start();
  twi_addressWrite(address);
  twi_write(0x40); // data mode (sending screen content)
  twi_write(0x00);
  twi_write(pgm_read_byte(&(font57[((unsigned char)ch * 5)])));
  twi_write(pgm_read_byte(&(font57[((unsigned char)ch * 5 + 1)])));
  twi_write(pgm_read_byte(&(font57[((unsigned char)ch * 5 + 2)])));
  twi_write(pgm_read_byte(&(font57[((unsigned char)ch * 5 + 3)])));
  twi_write(pgm_read_byte(&(font57[((unsigned char)ch * 5 + 4)])));
  twi_write(0x00);
  twi_stop();
}

// stdout-able output
static uint8_t oled_x = 0;
static uint8_t oled_y = 0;
static int oled_putchar(char c)
{
  if (c == '\n')
  {
    oled_x = 0;
    oled_goto(0, ++oled_y);
    return 0;
  }
  
  if (oled_x >= 128)
  {
    oled_x = 0;
    oled_goto(0, ++oled_y);
  }
  oled_print(c);
  oled_x++;
  return 0;
}
void oled_print_string(String s)
{
  for (uint8_t i = 0; i < s.length(); i++)
  {
    oled_putchar(s[i]);
  }
}

// Heart beat sensor setup for adc
String convertToString(int num)
{
  int i = 0;
  String str = "";
  while (num != 0)
  {
    int rem = num % 10;
    str = (char)(rem + '0') + str;
    num = num / 10;
  }
  return str + ".";
}

void InitADC()
{
  // Select Vref=AVcc
  ADMUX |= (1 << REFS0);
  // set prescaller to 128 and enable ADC
  ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1 << ADEN);
}

uint16_t ReadADC(uint8_t ADCchannel)
{
  // select ADC channel with safety mask
  ADMUX = (ADMUX & 0xF0) | (ADCchannel & 0x0F);
  // single conversion mode
  ADCSRA |= (1 << ADSC);
  // wait until ADC conversion is complete
  while (ADCSRA & (1 << ADSC))
    ;
  return ADC;
}

// interupt settup

void interruptSetup()
{
  // Initializes Timer2 to throw an interrupt every 2mS.
  TCCR2A = 0x02; // DISABLE PWM ON DIGITAL PINS 3 AND 11, AND GO INTO CTC MODE
  TCCR2B = 0x06; // DON'T FORCE COMPARE, 256 PRESCALER
  OCR2A = 0X7C;  // SET THE TOP OF THE COUNT TO 124 FOR 500Hz SAMPLE RATE
  TIMSK2 = 0x02; // ENABLE INTERRUPT ON MATCH BETWEEN TIMER2 AND OCR2A
  sei();         // MAKE SURE GLOBAL INTERRUPTS ARE ENABLED
}

ISR(TIMER2_COMPA_vect) // triggered when Timer2 counts to 124
{
  cli();                                    // disable interrupts while we do this
  Signal = ReadADC(2);                      // read the Pulse Sensor
  sampleCounter += 2;                       // keep track of the time in mS with this variable
  int N = sampleCounter - lastBeatTime;     // monitor the time since the last beat to avoid noise
                                            //  find the peak and trough of the pulse wave
  if (Signal < thresh && N > (IBI / 5) * 3) // avoid dichrotic noise by waiting 3/5 of last IBI
  {
    if (Signal < T) // T is the trough
    {
      T = Signal; // keep track of lowest point in pulse wave
    }
  }

  if (Signal > thresh && Signal > P)
  {             // thresh condition helps avoid noise
    P = Signal; // P is the peak
  }             // keep track of highest point in pulse wave

  //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
  // signal surges up in value every time there is a pulse
  if (N > 250)
  { // avoid high frequency noise
    if ((Signal > thresh) && (Pulse == false) && (N > (IBI / 5) * 3))
    {
      Pulse = true;                       // set the Pulse flag when we think there is a pulse
      IBI = sampleCounter - lastBeatTime; // measure time between beats in mS
      lastBeatTime = sampleCounter;       // keep track of time for next pulse

      if (secondBeat)
      {                              // if this is the second beat, if secondBeat == TRUE
        secondBeat = false;          // clear secondBeat flag
        for (int i = 0; i <= 9; i++) // seed the running total to get a realisitic BPM at startup
        {
          rate[i] = IBI;
        }
      }

      if (firstBeat) // if it's the first time we found a beat, if firstBeat == TRUE
      {
        firstBeat = false; // clear firstBeat flag
        secondBeat = true; // set the second beat flag
        sei();             // enable interrupts again
        return;            // IBI value is unreliable so discard it
      }
      // keep a running total of the last 10 IBI values
      word runningTotal = 0; // clear the runningTotal variable

      for (int i = 0; i <= 8; i++)
      {                          // shift data in the rate array
        rate[i] = rate[i + 1];   // and drop the oldest IBI value
        runningTotal += rate[i]; // add up the 9 oldest IBI values
      }

      rate[9] = IBI;              // add the latest IBI to the rate array
      runningTotal += rate[9];    // add the latest IBI to runningTotal
      runningTotal /= 10;         // average the last 10 IBI values
      BPM = 60000 / runningTotal; // how many beats can fit into a minute? that's BPM!
      QS = true;                  // set Quantified Self flag
      // QS FLAG IS NOT CLEARED INSIDE THIS ISR
    }
  }

  if (Signal < thresh && Pulse == true)
  {                       // when the values are going down, the beat is over
    Pulse = false;        // reset the Pulse flag so we can do it again
    amp = P - T;          // get amplitude of the pulse wave
    thresh = amp / 2 + T; // set thresh at 50% of the amplitude
    P = thresh;           // reset these for next time
    T = thresh;
  }

  if (N > 2500)
  {                               // if 2.5 seconds go by without a beat
    thresh = 512;                 // set thresh default
    P = 512;                      // set P default
    T = 512;                      // set T default
    lastBeatTime = sampleCounter; // bring the lastBeatTime up to date
    firstBeat = true;             // set these to avoid noise
    secondBeat = false;           // when we get the heartbeat back
  }

  sei(); // enable interrupts when youre done!
} // end isr

int main()
{
  // setup

  interruptSetup();
  DDRC = (1 << DDC4) | (1 << DDC5);
  PORTC |= (1 << PORTC4) | (1 << PORTC5); // enable pullups
  twi_init();
  oled_init();
  InitADC();

  while (1)
  {
    if(QS){
      oled_x = 0;
      oled_y = 0;
      oled_clear(0);
      oled_goto(4, 0);
      oled_print_string("Heart Beat Monitor");
      oled_y++;
      oled_goto(oled_x, ++oled_y);
      oled_print_string("BPM");
      oled_goto(50, oled_y);
      if(BPM < 100 && BPM > 60){
      oled_print_string(convertToString(BPM));
      oled_goto(0, ++oled_y);
      oled_y++;
      oled_print_string("Heart rate is ");
      oled_goto(0, ++oled_y);
      oled_print_string("normal");
      }
      else if(BPM > 100 && BPM < 130){
        oled_print_string(convertToString(BPM));
        oled_y++;
        oled_goto(0, ++oled_y);
        oled_print_string("Heart rate is high");
      }
      else if(BPM < 60 && BPM > 40){
        oled_print_string(convertToString(BPM));
        oled_y++;
        oled_goto(0, ++oled_y);
        oled_print_string("Heart rate is low");
      }
      else{
        oled_print_string("Error");
      }
      QS = false; // reset the Quantified Self flag for next time
    }
    _delay_ms(20);
    
  }
}
